using Benutomo.EqualsGenerator.Embedding;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Reflection;
using System.Text;
using System.Threading;

namespace Benutomo.EqualsGenerator
{
    [Generator(LanguageNames.CSharp)]
    public partial class IncrementalGenerator : IIncrementalGenerator
    {

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            StaticSources.StaticSource.Register(context);

            var compilationProvider = context.CompilationProvider
                .Select((compilation, cancellationToken) => (compilation, usingSymbols: new UsingSymbols(compilation)));

            var anotatedClasses = context.SyntaxProvider
                .ForAttributeWithMetadataName(StaticSourceAttribute.GetFullyQualifiedMetadataName<AutomaticEqualsImplAttribute>(), Predicate, Transform)
                .Where(v => v.targetSymbol is not null)
                .Select((v, ct) => (v.targetSymbol!, new UsingSymbols(v.semanticModel.Compilation), v.semanticModel));

            context.RegisterSourceOutput(anotatedClasses, Generate);
        }

        static bool Predicate(SyntaxNode node, CancellationToken cancellationToken)
        {
            return node is TypeDeclarationSyntax
            {
                AttributeLists.Count: > 0
            };
        }

        static (INamedTypeSymbol? targetSymbol, SemanticModel semanticModel) Transform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
        {
            var typeDeclarationSyntax = (TypeDeclarationSyntax)context.TargetNode;

            if (!typeDeclarationSyntax.Modifiers.Any(modifier => modifier.ValueText == "partial"))
            {
                return default;
            }

            var namedTypeSymbol = context.SemanticModel.GetDeclaredSymbol(typeDeclarationSyntax, cancellationToken) as INamedTypeSymbol;

            return (namedTypeSymbol, context.SemanticModel);
        }

        void Generate(SourceProductionContext context, (INamedTypeSymbol targetSymbol, UsingSymbols usingSymbols, SemanticModel semanticModel) generateArgs)
        {
            using var builder = new SourceBuilderEx(context);

            var typeDefinitionInfo = generateArgs.targetSymbol.BuildTypeDefinitionInfo();

            builder.AppendLine(generateArgs.semanticModel.SyntaxTree.GetCompilationUnitRoot().Usings.ToString());

            builder.AppendLine("#nullable enable");
            builder.AppendLine("#pragma warning disable CS0612,CS0618,CS0619");
            builder.AppendLine("#pragma warning disable CS0436");

            using (builder.BeginTypeDefinitionBlock(typeDefinitionInfo, $" : System.IEquatable<{typeDefinitionInfo.NameWithGenericArgs}>  // This is generated by EqualsGenerator."))
            {
                var members = EqualsHelper.EnumerateValidMembers(generateArgs.targetSymbol, generateArgs.usingSymbols, generateArgs.semanticModel, context.CancellationToken)
                    .Select(member =>
                    {
                        var equalityComparerAttribute = member.symbol.GetAttributes()
                            .FirstOrDefault(v => SymbolEqualityComparer.Default.Equals(v.AttributeClass, generateArgs.usingSymbols.EqualityComparerAttribute));

                        string equalityComparer;

                        if (equalityComparerAttribute is not null)
                        {
                            equalityComparer = "0 /* The type of IEqualityComparer<T> could not be identified. */";

                            var equalityComparerAttributeSyntaxReference = equalityComparerAttribute.ApplicationSyntaxReference;

                            var syntaxNode = equalityComparerAttributeSyntaxReference?.GetSyntax();

                            if (syntaxNode is AttributeSyntax attributeSyntax
                                && attributeSyntax.ArgumentList is { Arguments.Count: 1 } attributreArgListSyntax
                                && attributreArgListSyntax.Arguments[0].Expression is InvocationExpressionSyntax { ArgumentList.Arguments.Count: 1 } invocationExpressionSyntax
                                && invocationExpressionSyntax.Expression is IdentifierNameSyntax { Identifier.ValueText: "nameof" }
                                )
                            {
                                var nameofTargetExpression = invocationExpressionSyntax.ArgumentList.Arguments[0].Expression;

                                var semanticModelForReferenceSyntaxNode = generateArgs.semanticModel.Compilation.GetSemanticModel(syntaxNode.SyntaxTree);

                                var symbolInfo = semanticModelForReferenceSyntaxNode.GetSymbolInfo(nameofTargetExpression, context.CancellationToken);

                                if (symbolInfo.Symbol is not null)
                                {
                                    equalityComparer = symbolInfo.Symbol.ToString();
                                }
                            }
                        }
                        else
                        {
                            var equalityComparerBuilder = new StringBuilder(256);

                            equalityComparerBuilder.Append("System.Collections.Generic.EqualityComparer<");
                            equalityComparerBuilder.AppendFullTypeName(member.type);
                            equalityComparerBuilder.Append(">.Default");

                            equalityComparer = equalityComparerBuilder.ToString();
                        }

                        return (member.symbol, member.type, equalityComparer);
                    });

                var baseTypeEqualsQuery = enumerableBaseTypeEqualsMethodTypes(generateArgs.targetSymbol.BaseType)
                    .Distinct(SymbolEqualityComparer.Default)
                    .Select(v => (ITypeSymbol)v!);

                foreach (var baseTypeEqualsType in baseTypeEqualsQuery)
                {
                    ITypeSymbol argTypeSymbol;
                    if (baseTypeEqualsType.IsValueType)
                    {
                        argTypeSymbol = baseTypeEqualsType;
                    }
                    else
                    {
                        argTypeSymbol = baseTypeEqualsType.WithNullableAnnotation(NullableAnnotation.Annotated);
                    }
                    
                    using (builder.BeginBlock($@"public override bool Equals({argTypeSymbol} other)"))
                    {
                        builder.PutIndentSpace();
                        builder.Append("return other is ");
                        builder.Append(typeDefinitionInfo.NameWithGenericArgs);
                        builder.Append(" _other && this.Equals(_other);");
                        builder.AppendLine();
                    }
                }

                IEnumerable<ITypeSymbol> enumerableBaseTypeEqualsMethodTypes(INamedTypeSymbol? baseType)
                {
                    while (baseType is not null)
                    {
                        foreach (var member in baseType.GetMembers(nameof(Equals)))
                        {
                            if (member is not IMethodSymbol methodSymbol) continue;
                            if (methodSymbol.ReturnType.SpecialType != SpecialType.System_Boolean) continue;
                            if (methodSymbol.Parameters.Length == 1) continue;

                            yield return methodSymbol.Parameters[0].Type;
                        }

                        baseType = baseType.BaseType;
                    }
                }

                using (builder.BeginBlock($@"public override int GetHashCode()"))
                {
                    builder.PutIndentSpace();
                    builder.AppendLine($@"var hashCode = new System.HashCode();");

                    if (!generateArgs.targetSymbol.IsValueType && generateArgs.targetSymbol.BaseType is { SpecialType: not SpecialType.System_Object })
                    {
                        builder.PutIndentSpace();
                        builder.AppendLine("hashCode.Add(base.GetHashCode());");
                    }

                    foreach (var member in members)
                    {
                        builder.PutIndentSpace();
                        builder.Append("hashCode.Add(");
                        builder.Append(member.symbol.Name);
                        builder.Append(", ");
                        builder.Append(member.equalityComparer);
                        builder.Append(");");
                        builder.AppendLine();
                    }

                    builder.PutIndentSpace();
                    builder.AppendLine("return hashCode.ToHashCode();");
                }

                using (builder.BeginBlock($@"public{(generateArgs.targetSymbol.IsSealed ? " " : " virtual")} bool Equals({typeDefinitionInfo.NameWithGenericArgs}{(generateArgs.targetSymbol.IsValueType ? "": "?")} other)"))
                {
                    builder.PutIndentSpace();
                    if (generateArgs.targetSymbol.IsValueType)
                    {
                        builder.AppendLine($@"return true");
                    }
                    else
                    {
                        builder.AppendLine($@"return other is not null");
                    }

                    if (!generateArgs.targetSymbol.IsValueType && generateArgs.targetSymbol.BaseType is { SpecialType: not SpecialType.System_Object })
                    {
                        builder.PutIndentSpace();
                        builder.AppendLine("  && base.Equals(other)");
                    }

                    foreach (var member in members)
                    {
                        builder.PutIndentSpace();
                        builder.Append("  && ");
                        builder.Append(member.equalityComparer);
                        builder.Append(".Equals(this.");
                        builder.Append(member.symbol.Name);
                        builder.Append(", other.");
                        builder.Append(member.symbol.Name);
                        builder.Append(")");
                        builder.AppendLine();
                    }

                    builder.PutIndentSpace();
                    builder.AppendLine("  ;");
                }
            }

            context.AddSource(typeDefinitionInfo.MakeHintName(), builder.SourceText);
        }
    }
}
