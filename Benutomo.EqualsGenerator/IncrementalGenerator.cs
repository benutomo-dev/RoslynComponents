using Benutomo.EqualsGenerator.Embedding;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace Benutomo.EqualsGenerator
{
    [Generator(LanguageNames.CSharp)]
    public partial class IncrementalGenerator : IIncrementalGenerator
    {

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            StaticSources.StaticSource.Register(context);

            var compilationProvider = context.CompilationProvider
                .Select((compilation, cancellationToken) => (compilation, usingSymbols: new UsingSymbols(compilation)));

            var anotatedClasses = context.SyntaxProvider
                .ForAttributeWithMetadataName(StaticSourceAttribute.GetFullyQualifiedMetadataName<AutomaticEqualsImplAttribute>(), Predicate, Transform)
                .Where(v => v.targetSymbol is not null)
                .Select((v, ct) => (v.targetSymbol!, new UsingSymbols(v.semanticModel.Compilation), v.semanticModel));

            context.RegisterSourceOutput(anotatedClasses, Generate);
        }

        static bool Predicate(SyntaxNode node, CancellationToken cancellationToken)
        {
            return node is ClassDeclarationSyntax
            {
                AttributeLists.Count: > 0
            };
        }

        static (INamedTypeSymbol? targetSymbol, SemanticModel semanticModel) Transform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
        {
            var classDeclarationSyntax = (ClassDeclarationSyntax)context.TargetNode;

            if (!classDeclarationSyntax.Modifiers.Any(modifier => modifier.ValueText == "partial"))
            {
                return default;
            }

            var namedTypeSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax, cancellationToken) as INamedTypeSymbol;

            return (namedTypeSymbol, context.SemanticModel);
        }

        void Generate(SourceProductionContext context, (INamedTypeSymbol targetSymbol, UsingSymbols usingSymbols, SemanticModel semanticModel) generateArgs)
        {
            using var builder = new SourceBuilderEx(context);

            var typeDefinitionInfo = generateArgs.targetSymbol.BuildTypeDefinitionInfo();

            builder.AppendLine(generateArgs.semanticModel.SyntaxTree.GetCompilationUnitRoot().Usings.ToString());

            builder.AppendLine("#nullable enable");
            builder.AppendLine("#pragma warning disable CS0612,CS0618,CS0619");
            builder.AppendLine("#pragma warning disable CS0436");

            using (builder.BeginTypeDefinitionBlock(typeDefinitionInfo, $" : System.IEquatable<{typeDefinitionInfo.NameWithGenericArgs}>  // This is generated by EqualsGenerator."))
            {
                var shadowingMembersQuery = generateArgs.targetSymbol.GetMembers()
                    .Where(v => v is IFieldSymbol or IPropertySymbol)
                    .SelectMany(v => v.GetAttributes())
                    .Where(v => SymbolEqualityComparer.Default.Equals(v.AttributeClass, generateArgs.usingSymbols.RepresentingEquivalenceForAttribute))
                    .SelectMany(v => v.ConstructorArguments)
                    .SelectMany(v => v.Values)
                    .Select(v => v.Value?.ToString())
                    .Where(v => v is not null).Select(v => v!);

                var shadowingMembers = new HashSet<string>(shadowingMembersQuery);

                var members = enumerateValidMembers(generateArgs.targetSymbol, generateArgs.usingSymbols, generateArgs.semanticModel, shadowingMembers, context.CancellationToken).ToArray();

                using (builder.BeginBlock($@"public override bool Equals(object? other)"))
                {
                    builder.PutIndentSpace();
                    builder.Append("return other is ");
                    builder.Append(typeDefinitionInfo.NameWithGenericArgs);
                    builder.Append(" _other && Equals(this, _other);");
                    builder.AppendLine();
                }

                using (builder.BeginBlock($@"public override int GetHashCode()"))
                {
                    builder.PutIndentSpace();
                    builder.AppendLine($@"var hashCode = new System.HashCode();");

                    if (generateArgs.targetSymbol.BaseType is { SpecialType: not SpecialType.System_Object })
                    {
                        builder.PutIndentSpace();
                        builder.AppendLine("hashCode.Add(base.GetHashCode());");
                    }

                    foreach (var member in members)
                    {
                        builder.PutIndentSpace();
                        builder.Append("hashCode.Add(");
                        builder.Append(member.symbol.Name);
                        builder.Append(", ");
                        builder.Append(member.equalityComparer);
                        builder.Append(");");
                        builder.AppendLine();
                    }

                    builder.PutIndentSpace();
                    builder.AppendLine("return hashCode.ToHashCode();");
                }

                using (builder.BeginBlock($@"public virtual bool Equals({typeDefinitionInfo.NameWithGenericArgs} other)"))
                {
                    builder.PutIndentSpace();
                    builder.AppendLine($@"return true");

                    if (generateArgs.targetSymbol.BaseType is { SpecialType: not SpecialType.System_Object })
                    {
                        builder.PutIndentSpace();
                        builder.AppendLine("  && base.Equals(other)");
                    }

                    foreach (var member in members)
                    {
                        builder.PutIndentSpace();
                        builder.Append("  && ");
                        builder.Append(member.equalityComparer);
                        builder.Append(".Equals(this.");
                        builder.Append(member.symbol.Name);
                        builder.Append(", other.");
                        builder.Append(member.symbol.Name);
                        builder.Append(")");
                        builder.AppendLine();
                    }

                    builder.PutIndentSpace();
                    builder.AppendLine("  ;");
                }
            }

            context.AddSource(typeDefinitionInfo.MakeHintName(), builder.SourceText);

            static IEnumerable<(ISymbol symbol, ITypeSymbol type, string equalityComparer)> enumerateValidMembers(ITypeSymbol typeSymbol, UsingSymbols usingSymbols, SemanticModel semanticModel, HashSet<string> shadowingMembers, CancellationToken cancellationToken)
            {
                foreach (var member in typeSymbol.GetMembers())
                {
                    if (member.IsStatic) continue;

                    var isIgnoredMember = member.GetAttributes()
                        .Any(v => SymbolEqualityComparer.Default.Equals(v.AttributeClass, usingSymbols.IsNotEquivalenceFactorAttribute));

                    if (isIgnoredMember) continue;

                    ITypeSymbol memberType;

                    if (member is IFieldSymbol fieldSymbol)
                    {
                        if (fieldSymbol.IsImplicitlyDeclared) continue;

                        memberType = fieldSymbol.Type;
                    }
                    else if (member is IPropertySymbol propertySymbol)
                    {
                        if (propertySymbol.IsImplicitlyDeclared) continue;

                        memberType = propertySymbol.Type;
                    }
                    else
                    {
                        continue;
                    }

                    var equalityComparerAttribute = member.GetAttributes()
                        .FirstOrDefault(v => SymbolEqualityComparer.Default.Equals(v.AttributeClass, usingSymbols.EqualityComparerAttribute));

                    string equalityComparer;

                    if (equalityComparerAttribute is not null)
                    {
                        equalityComparer = "0 /* The type of IEqualityComparer<T> could not be identified. */";

                        var equalityComparerAttributeSyntaxReference = equalityComparerAttribute.ApplicationSyntaxReference;

                        var syntaxNode = equalityComparerAttributeSyntaxReference?.GetSyntax();

                        if (syntaxNode is AttributeSyntax attributeSyntax
                            && attributeSyntax.ArgumentList is { Arguments.Count: 1 } attributreArgListSyntax
                            && attributreArgListSyntax.Arguments[0].Expression is InvocationExpressionSyntax { ArgumentList.Arguments.Count: 1 } invocationExpressionSyntax
                            && invocationExpressionSyntax.Expression is IdentifierNameSyntax { Identifier.ValueText: "nameof" }
                            )
                        {
                            var nameofTargetExpression = invocationExpressionSyntax.ArgumentList.Arguments[0].Expression;

                            //equalityComparer = nameofTargetExpression.ToString();

                            var symbolInfo = semanticModel.GetSymbolInfo(nameofTargetExpression, cancellationToken);

                            if (symbolInfo.Symbol is not null)
                            {
                                equalityComparer = symbolInfo.Symbol.ToString();
                            }
                        }
                    }
                    else
                    {
                        var equalityComparerBuilder = new StringBuilder(256);

                        equalityComparerBuilder.Append("System.Collections.Generic.EqualityComparer<");
                        equalityComparerBuilder.AppendFullTypeName(memberType);
                        equalityComparerBuilder.Append(">.Default");

                        equalityComparer = equalityComparerBuilder.ToString();
                    }


                    if (shadowingMembers.Contains(member.Name)) continue;


                    yield return (member, memberType, equalityComparer);
                }
            }
        }
    }
}
