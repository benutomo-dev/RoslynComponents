using Benutomo.EqualsGenerator.Embedding;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Metadata;
using System.Text;
using System.Threading;

namespace Benutomo.EqualsGenerator
{
    [Generator(LanguageNames.CSharp)]
    public partial class IncrementalGenerator : IIncrementalGenerator
    {

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            StaticSources.StaticSource.Register(context);

            var compilationProvider = context.CompilationProvider
                .Select((compilation, cancellationToken) => (compilation, usingSymbols: new UsingSymbols(compilation)));

            var anotatedClasses = context.SyntaxProvider
                .ForAttributeWithMetadataName(StaticSourceAttribute.GetFullyQualifiedMetadataName<AutomaticEqualsImplAttribute>(), Predicate, Transform)
                .Where(v => v.targetSymbol is not null)
                .Select((v, ct) => (v.targetSymbol!, v.attribute, new UsingSymbols(v.semanticModel.Compilation), v.semanticModel));

            context.RegisterSourceOutput(anotatedClasses, Generate);
        }

        static bool Predicate(SyntaxNode node, CancellationToken cancellationToken)
        {
            return node is TypeDeclarationSyntax
            {
                AttributeLists.Count: > 0
            };
        }

        static (INamedTypeSymbol? targetSymbol, AttributeData attribute, SemanticModel semanticModel) Transform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
        {
            var typeDeclarationSyntax = (TypeDeclarationSyntax)context.TargetNode;

            if (!typeDeclarationSyntax.Modifiers.Any(modifier => modifier.ValueText == "partial"))
            {
                return default;
            }

            var namedTypeSymbol = context.SemanticModel.GetDeclaredSymbol(typeDeclarationSyntax, cancellationToken) as INamedTypeSymbol;

            Debug.Assert(context.Attributes.Length == 1);

            return (namedTypeSymbol, context.Attributes[0], context.SemanticModel);
        }

        void Generate(SourceProductionContext context, (INamedTypeSymbol targetSymbol, AttributeData attribute, UsingSymbols usingSymbols, SemanticModel semanticModel) generateArgs)
        {
            var typeDefinitionInfo = generateArgs.targetSymbol.BuildTypeDefinitionInfo();

            var hintName = typeDefinitionInfo.MakeHintName();

            using var builder = new SourceBuilderEx(context, $"{hintName}.cs");

#if !DEBUG
            builder.AppendLine("// <auto-generated />");
#endif

            builder.AppendLine(generateArgs.semanticModel.SyntaxTree.GetCompilationUnitRoot().Usings.ToString());

            builder.AppendLine("#nullable enable");
            builder.AppendLine("#pragma warning disable CS0612,CS0618,CS0619");
            builder.AppendLine("#pragma warning disable CS0436");

            using (builder.BeginTypeDefinitionBlock(typeDefinitionInfo, $" // This is generated by EqualsGenerator."))
            {
                var members = EqualsHelper.EnumerateValidMembers(generateArgs.targetSymbol, generateArgs.usingSymbols, generateArgs.semanticModel, context.CancellationToken)
                    .Select(member =>
                    {
                        var equalityComparerAttribute = member.symbol.GetAttributes()
                            .FirstOrDefault(v => SymbolEqualityComparer.Default.Equals(v.AttributeClass, generateArgs.usingSymbols.EqualityComparerAttribute));

                        string equalityComparer;

                        if (equalityComparerAttribute is not null)
                        {
                            equalityComparer = "0 /* The type of IEqualityComparer<T> could not be identified. */";

                            var equalityComparerAttributeSyntaxReference = equalityComparerAttribute.ApplicationSyntaxReference;

                            var syntaxNode = equalityComparerAttributeSyntaxReference?.GetSyntax();

                            if (syntaxNode is AttributeSyntax attributeSyntax
                                && attributeSyntax.ArgumentList is { Arguments.Count: 1 } attributreArgListSyntax
                                && attributreArgListSyntax.Arguments[0].Expression is InvocationExpressionSyntax { ArgumentList.Arguments.Count: 1 } invocationExpressionSyntax
                                && invocationExpressionSyntax.Expression is IdentifierNameSyntax { Identifier.ValueText: "nameof" }
                                )
                            {
                                var nameofTargetExpression = invocationExpressionSyntax.ArgumentList.Arguments[0].Expression;

                                var semanticModelForReferenceSyntaxNode = generateArgs.semanticModel.Compilation.GetSemanticModel(syntaxNode.SyntaxTree);

                                var symbolInfo = semanticModelForReferenceSyntaxNode.GetSymbolInfo(nameofTargetExpression, context.CancellationToken);

                                if (symbolInfo.Symbol is not null)
                                {
                                    equalityComparer = symbolInfo.Symbol.ToString();
                                }
                            }
                        }
                        else
                        {
                            var equalityComparerBuilder = new StringBuilder(256);

                            equalityComparerBuilder.Append("System.Collections.Generic.EqualityComparer<");
                            equalityComparerBuilder.AppendFullTypeNameWithNamespaceAlias(member.type);
                            equalityComparerBuilder.Append(">.Default");

                            equalityComparer = equalityComparerBuilder.ToString();
                        }

                        return (member.symbol, member.type, member.isHashCodeCache, equalityComparer);
                    })
                    .ToArray();

                var baseTypeEqualsQuery = enumerableBaseTypeEqualsMethodTypes(generateArgs.targetSymbol.BaseType)
                    .Distinct(SymbolEqualityComparer.Default)
                    .Select(v => (ITypeSymbol)v!);

                var hashCodeCacheField = members.FirstOrDefault(v => v.isHashCodeCache);

                foreach (var baseTypeEqualsType in baseTypeEqualsQuery)
                {
                    ITypeSymbol argBaseTypeSymbol;
                    if (baseTypeEqualsType.IsValueType)
                    {
                        argBaseTypeSymbol = baseTypeEqualsType;
                    }
                    else
                    {
                        argBaseTypeSymbol = baseTypeEqualsType.WithNullableAnnotation(NullableAnnotation.Annotated);
                    }
                    
                    using (builder.BeginBlock($@"public override bool Equals({argBaseTypeSymbol} other)"))
                    {
                        builder.PutIndentSpace();
                        builder.Append("return other is ");
                        builder.Append(typeDefinitionInfo.NameWithGenericArgs);
                        builder.Append(" _other && this.Equals(_other);");
                        builder.AppendLine();
                    }
                }

                IEnumerable<ITypeSymbol> enumerableBaseTypeEqualsMethodTypes(INamedTypeSymbol? baseType)
                {
                    while (baseType is not null)
                    {
                        foreach (var member in baseType.GetMembers(nameof(Equals)))
                        {
                            if (member is not IMethodSymbol methodSymbol) continue;
                            if (methodSymbol.ReturnType.SpecialType != SpecialType.System_Boolean) continue;
                            if (methodSymbol.Parameters.Length == 1) continue;

                            yield return methodSymbol.Parameters[0].Type;
                        }

                        baseType = baseType.BaseType;
                    }
                }

                using (builder.BeginBlock($@"public override int GetHashCode()"))
                {
                    SourceBuilderEx._BlockEndDisposable block = default;
                    try
                    {
                        if (hashCodeCacheField.symbol is not null)
                        {
                            block = builder.BeginBlock($@"if ({hashCodeCacheField.symbol.Name} == 0)");
                        }

                        builder.PutIndentSpace();
                        builder.AppendLine($@"var hashCode = new System.HashCode();");

                        if (!generateArgs.targetSymbol.IsValueType && generateArgs.targetSymbol.BaseType is { SpecialType: not SpecialType.System_Object })
                        {
                            builder.PutIndentSpace();
                            builder.AppendLine("hashCode.Add(base.GetHashCode());");
                        }

                        foreach (var member in members)
                        {
                            builder.PutIndentSpace();
                            builder.Append("hashCode.Add(this.");
                            builder.Append(member.symbol.Name);
                            builder.Append(", ");
                            builder.Append(member.equalityComparer);
                            builder.Append(");");
                            builder.AppendLine();
                        }

                        if (hashCodeCacheField.symbol is not null)
                        {
                            builder.PutIndentSpace();
                            builder.AppendLine($@"this.{hashCodeCacheField.symbol.Name} = hashCode.ToHashCode();");
                            builder.PutIndentSpace();
                            builder.AppendLine($@"if (this.{hashCodeCacheField.symbol.Name} == 0) this.{hashCodeCacheField.symbol.Name} = 1;");
                        }
                    }
                    finally
                    {
                        block.Dispose();
                    }

                    if (hashCodeCacheField.symbol is not null)
                    {
                        builder.PutIndentSpace();
                        builder.AppendLine($@"return this.{hashCodeCacheField.symbol.Name};");
                    }
                    else
                    {
                        builder.PutIndentSpace();
                        builder.AppendLine($@"return hashCode.ToHashCode();");
                    }
                }

                using (builder.BeginBlock($@"public{(generateArgs.targetSymbol.IsSealed ? " " : " virtual")} bool Equals({typeDefinitionInfo.NameWithGenericArgs}{(generateArgs.targetSymbol.IsValueType ? "": "?")} other)"))
                {
                    if (!generateArgs.targetSymbol.IsValueType)
                    {
                        builder.PutIndentSpace();
                        builder.AppendLine($@"if (other is null) return false;");

                        builder.PutIndentSpace();
                        builder.AppendLine($@"if (object.ReferenceEquals(this, other)) return true;");
                    }

                    builder.PutIndentSpace();
                    builder.AppendLine($@"return true");

                    if (hashCodeCacheField.symbol is not null)
                    {
                        builder.PutIndentSpace();
                        builder.AppendLine($@"  && this.GetHashCode() == other.GetHashCode()");
                    }

                    if (!generateArgs.targetSymbol.IsValueType && generateArgs.targetSymbol.BaseType is { SpecialType: not SpecialType.System_Object })
                    {
                        builder.PutIndentSpace();
                        builder.AppendLine("  && base.Equals(other)");
                    }

                    foreach (var member in members)
                    {
                        builder.PutIndentSpace();
                        builder.Append("  && ");
                        builder.Append(member.equalityComparer);
                        builder.Append(".Equals(this.");
                        builder.Append(member.symbol.Name);
                        builder.Append(", other.");
                        builder.Append(member.symbol.Name);
                        builder.Append(")");
                        builder.AppendLine();
                    }

                    builder.PutIndentSpace();
                    builder.AppendLine("  ;");
                }

                var options = (AutomaticEqualsImplOptions)(int)generateArgs.attribute.ConstructorArguments[0].Value!;

                if (options.HasFlag(AutomaticEqualsImplOptions.WithOperator))
                {
                    using (builder.BeginBlock($@"public static bool operator ==({typeDefinitionInfo.NameWithGenericArgs}{(generateArgs.targetSymbol.IsValueType ? "" : "?")} left, {typeDefinitionInfo.NameWithGenericArgs}{(generateArgs.targetSymbol.IsValueType ? "" : "?")} right)"))
                    {
                        builder.PutIndentSpace();
                        builder.AppendLine($@"return System.Collections.Generic.EqualityComparer<{typeDefinitionInfo.NameWithGenericArgs}>.Default.Equals(left, right);");
                    }

                    using (builder.BeginBlock($@"public static bool operator !=({typeDefinitionInfo.NameWithGenericArgs}{(generateArgs.targetSymbol.IsValueType ? "" : "?")} left, {typeDefinitionInfo.NameWithGenericArgs}{(generateArgs.targetSymbol.IsValueType ? "" : "?")} right)"))
                    {
                        builder.PutIndentSpace();
                        builder.AppendLine($@"return !System.Collections.Generic.EqualityComparer<{typeDefinitionInfo.NameWithGenericArgs}>.Default.Equals(left, right);");
                    }
                }
            }

            builder.Commit();
        }
    }
}
