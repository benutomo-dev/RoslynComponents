using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace Benutomo.Cs0436Relaxation
{
    [DiagnosticAnalyzer(LanguageNames.CSharp)]
    internal class Analyzer : DiagnosticAnalyzer
    {
        static readonly char[] s_pathSeparaters = new char[] { '\\', '/' };


        /// <summary>
        /// editorconfigファイルの編集が必要。
        /// </summary>
        internal static DiagnosticDescriptor s_diagnosticDescriptor_RX_CS0436_0 = new DiagnosticDescriptor(
            "RX_CS0436_0",
            "The editorconfig file needs to be prepared",
            @"You must place an editorconfig file in your project that contains the following settings. ""dotnet_diagnostic.CS0436.severity = suggestion"".",
            "Usage",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);

        /// <summary>
        /// ソースジェネレータによって生成されていないソースのシンボルに対してCS0436が発生。
        /// </summary>
        internal static DiagnosticDescriptor s_diagnosticDescriptor_RX_CS0436_1 = new DiagnosticDescriptor(
            "RX_CS0436_1",
            "CS0436 occurs for symbols in sources not generated by the source generator",
            "{0}",
            "Usage",
            DiagnosticSeverity.Warning,
            isEnabledByDefault: true);


        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; } = ImmutableArray.Create(
            s_diagnosticDescriptor_RX_CS0436_0,
            s_diagnosticDescriptor_RX_CS0436_1
            );

#if DEBUG
        [SuppressMessage("MicrosoftCodeAnalysisCorrectness", "RS1026:同時実行を有効にします", Justification = "<保留中>")]
#endif
        public override void Initialize(AnalysisContext context)
        {
#if !DEBUG
            context.EnableConcurrentExecution();
#endif
            context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.Analyze | GeneratedCodeAnalysisFlags.ReportDiagnostics);
            context.RegisterSemanticModelAction(SemanticModelAction);
            context.RegisterCompilationAction(CompilationAction);
        }

        private void CompilationAction(CompilationAnalysisContext context)
        {
            var syntaxTreeOptionsProvider = context.Compilation.Options.SyntaxTreeOptionsProvider;

            if (syntaxTreeOptionsProvider is null)
            {
                throw new InvalidOperationException("SyntaxTreeOptionsProviderが取得できませんでした。");
            }

            foreach (var diagnostic in context.Compilation.GetDeclarationDiagnostics(context.CancellationToken))
            {
                if (!IsCs0436(diagnostic))
                {
                    continue;
                }

                if (!IsSuppressed(diagnostic))
                {
                    context.ReportDiagnostic(Diagnostic.Create(s_diagnosticDescriptor_RX_CS0436_0, Location.None));
                    return;
                }
            }
        }

        private void SemanticModelAction(SemanticModelAnalysisContext context)
        {
            // ここで、context.SemanticModel.Compilation.GetDiagnosticsを呼び出すと、
            // おそらく、偶発的にメソッドのコンパイル完了前のSyntaxTreeのDiagnosticsの取得がされる場合がある関係で、
            // とくに、大きなプロジェクトのビルド途中でコンパイラが異常終了する現象が発生するようになるので注意

            var diagnotics = context.SemanticModel.GetDiagnostics(null, context.CancellationToken);

            var syntaxTreeOptionsProvider = context.SemanticModel.Compilation.Options.SyntaxTreeOptionsProvider;

            if (syntaxTreeOptionsProvider is null)
            {
                throw new InvalidOperationException("SyntaxTreeOptionsProviderが取得できませんでした。");
            }

            foreach (var diagnostic in diagnotics)
            {
                if (diagnostic.Location.SourceTree != context.SemanticModel.SyntaxTree)
                {
                    continue;
                }

                if (!IsSuppressed(diagnostic))
                {
                    // 生のCS04036がinfo以下相当に抑止されていないならば、RX_CS0436_1を出す必要はない。
                    // ※ そのときは、別ルートでeditorconfigの準備を促す(RX_CS0436_0)が発生する。
                    continue;
                }

                if (!IsCs0436(diagnostic))
                {
                    continue;
                }

                if (!IsOccuredForAutogeneratedSysmbol(diagnostic, context.SemanticModel, syntaxTreeOptionsProvider, context.CancellationToken))
                {
                    context.ReportDiagnostic(Diagnostic.Create(s_diagnosticDescriptor_RX_CS0436_1, diagnostic.Location, diagnostic.GetMessage()));
                }
            }
        }

        private static bool IsSuppressed(Diagnostic diagnostic)
        {
            if (diagnostic.IsSuppressed || (diagnostic.Severity != DiagnosticSeverity.Warning && diagnostic.Severity != DiagnosticSeverity.Error))
            {
                return true;
            }

            return false;
        }

        private static bool IsCs0436(Diagnostic diagnostic)
        {
            return diagnostic.Id == "CS0436";
        }

        private static bool IsOccuredForAutogeneratedSysmbol(Diagnostic diagnostic, SemanticModel semanticModel, SyntaxTreeOptionsProvider syntaxTreeOptionsProvider, CancellationToken cancellationToken)
        {
            if (diagnostic.Location.SourceTree != semanticModel.SyntaxTree)
            {
                Debug.Fail("診断結果とセマンティックモデルのSystexTreeが不一致");
                return false;
            }

            var node = semanticModel.SyntaxTree.GetRoot().FindNode(diagnostic.Location.SourceSpan);

            if (node is null)
            {
                return false;
            }

            var symbolInfo = semanticModel.GetSymbolInfo(node, cancellationToken);

            if (symbolInfo.Symbol is null)
            {
                return false;
            }

            if (symbolInfo.Symbol.Locations.Length == 0)
            {
                return false;
            }

            foreach (var location in symbolInfo.Symbol.Locations)
            {
                if (!IsGeneratedCode(location, syntaxTreeOptionsProvider, cancellationToken))
                {
                    return false;
                }
            }

            return true;
        }

        private static bool IsGeneratedCode(Location location, SyntaxTreeOptionsProvider syntaxTreeOptionsProvider, CancellationToken cancellationToken)
        {
            if (location.SourceTree is null) return false;

            var generatedKind = syntaxTreeOptionsProvider.IsGenerated(location.SourceTree, cancellationToken);

            if (generatedKind == GeneratedKind.NotGenerated) return false;

            // 現在の実装上、絶対パスの場合はソースジェネレータの生成コードではない
            if (Path.IsPathRooted(location.SourceTree.FilePath)) return false;


            // 現在の実装上、ソースジェネレータの生成コードのパスは
            //   {アセンブリ名}/{生成クラス名}/{ソース登録時のHintName}

            var filePathComponents = location.SourceTree.FilePath.Split(s_pathSeparaters, 3, StringSplitOptions.None);

            if (filePathComponents.Length < 3) return false;

            foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                if (assembly.GetName().Name != filePathComponents[0])
                {
                    continue;
                }

                var type = assembly.GetType(filePathComponents[1]);

                if (type is null)
                {
                    return false;
                }

                if (Attribute.IsDefined(type, typeof(GeneratorAttribute)))
                {
                    // ソースジェネレータによって生成されたソースファイルと見做す
                    return true;
                }
                else
                {
                    return false;
                }
            }

            return false;
        }

    }
}
